/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

export interface ParquetConfig {
  /** Path to write parquet files to */
  path: string
  /** Convert binary output columns to hex */
  hexOutput?: boolean
  /** Block range size to use when making individual requests. */
  batchSize?: number
  /** Controls the number of concurrent requests made to hypersync server. */
  concurrency?: number
  /** Requests are retried forever internally if this param is set to true. */
  retry?: boolean
  /** Define type mapping for output columns */
  columnMapping?: ColumnMapping
  /** Event signature for decoding logs */
  eventSignature?: string
}
export interface ColumnMapping {
  block?: Record<string, string>
  transaction?: Record<string, string>
  log?: Record<string, string>
  decodedLog?: Record<string, string>
}
export interface StreamConfig {
  /** Block range size to use when making individual requests. */
  batchSize?: number
  /** Controls the number of concurrent requests made to hypersync server. */
  concurrency?: number
  /** Requests are retried forever internally if this param is set to true. */
  retry?: boolean
}
export interface Config {
  /** Url of the source hypersync instance */
  url: string
  /** Optional bearer_token to put into http requests made to source hypersync instance */
  bearerToken?: string
  /** Timout treshold for a single http request in milliseconds, default is 30 seconds (30_000ms) */
  httpReqTimeoutMillis?: number
}
export interface LogSelection {
  /**
   * Address of the contract, any logs that has any of these addresses will be returned.
   * Empty means match all.
   */
  address?: Array<string>
  /**
   * Topics to match, each member of the top level array is another array, if the nth topic matches any
   *  topic specified in topics[n] the log will be returned. Empty means match all.
   */
  topics?: Array<Array<string>>
}
export interface TransactionSelection {
  /**
   * Address the transaction should originate from. If transaction.from matches any of these, the transaction
   *  will be returned. Keep in mind that this has an and relationship with to filter, so each transaction should
   *  match both of them. Empty means match all.
   */
  from?: Array<string>
  /**
   * Address the transaction should go to. If transaction.to matches any of these, the transaction will
   *  be returned. Keep in mind that this has an and relationship with from filter, so each transaction should
   *  match both of them. Empty means match all.
   */
  to?: Array<string>
  /** If first 4 bytes of transaction input matches any of these, transaction will be returned. Empty means match all. */
  sighash?: Array<string>
  /** If tx.status matches this it will be returned. */
  status?: number
}
export interface FieldSelection {
  block?: Array<string>
  transaction?: Array<string>
  log?: Array<string>
}
export interface Query {
  /** The block to start the query from */
  fromBlock: number
  /**
   * The block to end the query at. If not specified, the query will go until the
   *  end of data. Exclusive, the returned range will be [from_block..to_block).
   *
   * The query will return before it reaches this target block if it hits the time limit
   *  configured on the server. The user should continue their query by putting the
   *  next_block field in the response into from_block field of their next query. This implements
   *  pagination.
   */
  toBlock?: number
  /**
   * List of log selections, these have an or relationship between them, so the query will return logs
   * that match any of these selections.
   */
  logs?: Array<LogSelection>
  /**
   * List of transaction selections, the query will return transactions that match any of these selections and
   *  it will return transactions that are related to the returned logs.
   */
  transactions?: Array<TransactionSelection>
  /**
   * Weather to include all blocks regardless of if they are related to a returned transaction or log. Normally
   *  the server will return only the blocks that are related to the transaction or logs in the response. But if this
   *  is set to true, the server will return data for all blocks in the requested range [from_block, to_block).
   */
  includeAllBlocks?: boolean
  /**
   * Field selection. The user can select which fields they are interested in, requesting less fields will improve
   *  query execution time and reduce the payload size so the user should always use a minimal number of fields.
   */
  fieldSelection: FieldSelection
  /**
   * Maximum number of blocks that should be returned, the server might return more blocks than this number but
   *  it won't overshoot by too much.
   */
  maxNumBlocks?: number
  /**
   * Maximum number of transactions that should be returned, the server might return more transactions than this number but
   *  it won't overshoot by too much.
   */
  maxNumTransactions?: number
  /**
   * Maximum number of logs that should be returned, the server might return more logs than this number but
   *  it won't overshoot by too much.
   */
  maxNumLogs?: number
}
/** Data relating to a single event (log) */
export interface Event {
  /** Transaction that triggered this event */
  transaction?: Transaction
  /** Block that this event happened in */
  block?: Block
  /** Evm log data */
  log: Log
}
/**
 * Evm log object
 *
 * See ethereum rpc spec for the meaning of fields
 */
export interface Log {
  removed?: boolean
  logIndex: number
  transactionIndex: number
  transactionHash?: string
  blockHash?: string
  blockNumber: number
  address?: string
  data?: string
  topics: Array<string | undefined | null>
}
/**
 * Evm transaction object
 *
 * See ethereum rpc spec for the meaning of fields
 */
export interface Transaction {
  blockHash?: string
  blockNumber: number
  from?: string
  gas?: string
  gasPrice?: string
  hash?: string
  input?: string
  nonce?: string
  to?: string
  transactionIndex: number
  value?: string
  v?: string
  r?: string
  s?: string
  maxPriorityFeePerGas?: string
  maxFeePerGas?: string
  chainId?: string
  cumulativeGasUsed?: string
  effectiveGasPrice?: string
  gasUsed?: string
  contractAddress?: string
  logsBloom?: string
  kind?: number
  root?: string
  status?: number
}
/**
 * Evm block header object
 *
 * See ethereum rpc spec for the meaning of fields
 */
export interface Block {
  number: number
  hash?: string
  parentHash?: string
  nonce?: string
  sha3Uncles?: string
  logsBloom?: string
  transactionsRoot?: string
  stateRoot?: string
  receiptsRoot?: string
  miner?: string
  difficulty?: string
  totalDifficulty?: string
  extraData?: string
  size?: string
  gasLimit?: string
  gasUsed?: string
  timestamp?: number
  baseFeePerGas?: string
}
/** Decoded EVM log */
export interface DecodedEvent {
  indexed: Array<DecodedSolValue>
  body: Array<DecodedSolValue>
}
export interface DecodedSolValue {
  val: boolean | bigint | string | Array<DecodedSolValue>
}
export interface QueryResponseData {
  blocks: Array<Block>
  transactions: Array<Transaction>
  logs: Array<Log>
}
export interface RollbackGuard {
  /** Block number of the last scanned block */
  blockNumber: number
  /** Block timestamp of the last scanned block */
  timestamp: number
  /** Block hash of the last scanned block */
  hash: string
  /**
   * Block number of the first scanned block in memory.
   *
   * This might not be the first scanned block. It only includes blocks that are in memory (possible to be rolled back).
   */
  firstBlockNumber: number
  /**
   * Parent hash of the first scanned block in memory.
   *
   * This might not be the first scanned block. It only includes blocks that are in memory (possible to be rolled back).
   */
  firstParentHash: string
}
export interface QueryResponse {
  /** Current height of the source hypersync instance */
  archiveHeight?: number
  /**
   * Next block to query for, the responses are paginated so,
   *  the caller should continue the query from this block if they
   *  didn't get responses up to the to_block they specified in the Query.
   */
  nextBlock: number
  /** Total time it took the hypersync instance to execute the query. */
  totalExecutionTime: number
  /** Response data */
  data: QueryResponseData
  /** Rollback guard, supposed to be used to detect rollbacks */
  rollbackGuard?: RollbackGuard
}
export interface Events {
  /** Current height of the source hypersync instance */
  archiveHeight?: number
  /**
   * Next block to query for, the responses are paginated so,
   *  the caller should continue the query from this block if they
   *  didn't get responses up to the to_block they specified in the Query.
   */
  nextBlock: number
  /** Total time it took the hypersync instance to execute the query. */
  totalExecutionTime: number
  /** Response data */
  events: Array<Event>
  /** Rollback guard, supposed to be used to detect rollbacks */
  rollbackGuard?: RollbackGuard
}
export class Decoder {
  static new(jsonAbis: Record<string, any>): Decoder
  enableChecksummedAddresses(): void
  disableChecksummedAddresses(): void
  decodeLogs(logs: Array<Log>): Promise<Array<DecodedEvent | undefined | null>>
  decodeLogsSync(logs: Array<Log>): Array<DecodedEvent | undefined | null>
  decodeEvents(events: Array<Event>): Promise<Array<DecodedEvent | undefined | null>>
  decodeEventsSync(events: Array<Event>): Array<DecodedEvent | undefined | null>
}
export class HypersyncClient {
  /** Create a new client with given config */
  static new(cfg: Config): HypersyncClient
  /** Get the height of the source hypersync instance */
  getHeight(): Promise<number>
  /**
   * Stream data from hypersync server concurrently using the given query
   *
   * This parallelizes the hypersync queries so will have higher performance compared to
   *  regular .send methods.
   *
   * If query.to_block is not specified, this stream will stop at the block height of the source
   *  hypersync node. It is not continuous.
   */
  stream(query: Query, config: StreamConfig): Promise<QueryResponseStream>
  /**
   * Stream events data from hypersync server concurrently using the given query
   *
   * This parallelizes the hypersync queries so will have higher performance compared to
   *  regular .send methods.
   *
   * If query.to_block is not specified, this stream will stop at the block height of the source
   *  hypersync node. It is not continuous.
   */
  streamEvents(query: Query, config: StreamConfig): Promise<EventsStream>
  /**
   * Create a parquet file by executing a query.
   *
   * Path should point to a folder that will contain the parquet files in the end.
   */
  createParquetFolder(query: Query, config: ParquetConfig): Promise<void>
  /**
   * Send a query request to the source hypersync instance.
   *
   * Returns a query response which contains block, tx and log data.
   */
  sendReq(query: Query): Promise<QueryResponse>
  /**
   * Send a event query request to the source hypersync instance.
   *
   * This executes the same query as send_req function on the source side but
   * it groups data for each event(log) so it is easier to process it.
   */
  sendEventsReq(query: Query): Promise<Events>
}
export class QueryResponseStream {
  recv(): Promise<Error | QueryResponse | null>
}
export class EventsStream {
  recv(): Promise<Error | Events | null>
}
