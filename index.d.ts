/* auto-generated by NAPI-RS */
/* eslint-disable */
/** Decoder for Ethereum function calls */
export declare class CallDecoder {
  /** Create call decoder from function signatures */
  static fromSignatures(signatures: Array<string>): CallDecoder
  /** Create call decoder from function signatures with checksum option */
  static fromSignaturesWithChecksum(signatures: Array<string>, checksum: boolean): CallDecoder
  /** Decode function call inputs asynchronously */
  decodeInputs(inputs: Array<string>): Promise<Array<Array<DecodedSolValue> | undefined | null>>
  /** Decode transaction inputs asynchronously */
  decodeTransactionsInput(txs: Array<Transaction>): Promise<Array<Array<DecodedSolValue> | undefined | null>>
  /** Decode trace inputs asynchronously */
  decodeTracesInput(traces: Array<Trace>): Promise<Array<Array<DecodedSolValue> | undefined | null>>
  /** Decode function call inputs synchronously */
  decodeInputsSync(inputs: Array<string>): Array<Array<DecodedSolValue> | undefined | null>
  /** Decode transaction inputs synchronously */
  decodeTransactionsInputSync(txs: Array<Transaction>): Array<Array<DecodedSolValue> | undefined | null>
  /** Decode trace inputs synchronously */
  decodeTracesInputSync(traces: Array<Trace>): Array<Array<DecodedSolValue> | undefined | null>
  /** Decode a single input string */
  decodeImpl(input: string): Array<DecodedSolValue> | null
}

/** Decoder for Ethereum events and function calls */
export declare class Decoder {
  /** Create decoder from event signatures */
  static fromSignatures(signatures: Array<string>): Decoder
  /** Create decoder from event signatures with checksum option */
  static fromSignaturesWithChecksum(signatures: Array<string>, checksum: boolean): Decoder
  /** Enable checksummed addresses in decoded output */
  enableChecksummedAddresses(): void
  /** Disable checksummed addresses in decoded output */
  disableChecksummedAddresses(): void
  /** Decode logs asynchronously */
  decodeLogs(logs: Array<Log>): Promise<Array<DecodedEvent | undefined | null>>
  /** Decode logs synchronously */
  decodeLogsSync(logs: Array<Log>): Array<DecodedEvent | undefined | null>
  /** Decode events asynchronously */
  decodeEvents(events: Array<Event>): Promise<Array<DecodedEvent | undefined | null>>
  /** Decode events synchronously */
  decodeEventsSync(events: Array<Event>): Array<DecodedEvent | undefined | null>
}

/** Stream for receiving event responses */
export declare class EventStream {
  /** Close the event stream */
  close(): Promise<void>
  /** Receive the next event response from the stream */
  recv(): Promise<EventResponse | null>
}

/** HyperSync client for querying blockchain data */
export declare class HypersyncClient {
  /** Create a new client with given config */
  constructor(cfg: ClientConfig)
  /** Get the height of the source hypersync instance */
  getHeight(): Promise<number>
  /** Get the chain_id of the source hypersync instance */
  getChainId(): Promise<number>
  /** Collect blockchain data from the given query */
  collect(query: Query, config: StreamConfig): Promise<QueryResponse>
  /** Collect blockchain events from the given query */
  collectEvents(query: Query, config: StreamConfig): Promise<EventResponse>
  /** Collect blockchain data and save to parquet format */
  collectParquet(path: string, query: Query, config: StreamConfig): Promise<void>
  /** Get blockchain data for a single query */
  get(query: Query): Promise<QueryResponse>
  /** Get blockchain events for a single query */
  getEvents(query: Query): Promise<EventResponse>
  /** Stream blockchain data from the given query */
  stream(query: Query, config: StreamConfig): Promise<QueryResponseStream>
  /** Stream blockchain events from the given query */
  streamEvents(query: Query, config: StreamConfig): Promise<EventStream>
}

/** Stream for receiving query responses */
export declare class QueryResponseStream {
  /** Close the response stream */
  close(): Promise<void>
  /** Receive the next query response from the stream */
  recv(): Promise<QueryResponse | null>
}

/**
 * Evm access list object
 *
 * See ethereum rpc spec for the meaning of fields
 */
export interface AccessList {
  address?: string
  storageKeys?: Array<string>
}

/**
 * Evm authorization object
 *
 * See ethereum rpc spec for the meaning of fields
 */
export interface Authorization {
  /** uint256 */
  chainId: bigint
  /** 20-byte hex */
  address: string
  /** uint64 */
  nonce: number
  /** 0 | 1 */
  yParity: number
  /** 32-byte hex */
  r: string
  /** 32-byte hex */
  s: string
}

/** Selection criteria for transaction authorization lists */
export interface AuthorizationSelection {
  /** List of chain ids to match in the transaction authorizationList */
  chainId?: Array<number>
  /** List of addresses to match in the transaction authorizationList */
  address?: Array<string>
}

/**
 * Evm block header object
 *
 * See ethereum rpc spec for the meaning of fields
 */
export interface Block {
  number?: number
  hash?: string
  parentHash?: string
  nonce?: bigint
  sha3Uncles?: string
  logsBloom?: string
  transactionsRoot?: string
  stateRoot?: string
  receiptsRoot?: string
  miner?: string
  difficulty?: bigint
  totalDifficulty?: bigint
  extraData?: string
  size?: bigint
  gasLimit?: bigint
  gasUsed?: bigint
  timestamp?: number
  uncles?: Array<string>
  baseFeePerGas?: bigint
  blobGasUsed?: bigint
  excessBlobGas?: bigint
  parentBeaconBlockRoot?: string
  withdrawalsRoot?: string
  withdrawals?: Array<Withdrawal>
  l1BlockNumber?: number
  sendCount?: string
  sendRoot?: string
  mixHash?: string
}

/** Available fields for block data */
export type BlockField =  'Number'|
'Hash'|
'ParentHash'|
'Nonce'|
'Sha3Uncles'|
'LogsBloom'|
'TransactionsRoot'|
'StateRoot'|
'ReceiptsRoot'|
'Miner'|
'Difficulty'|
'TotalDifficulty'|
'ExtraData'|
'Size'|
'GasLimit'|
'GasUsed'|
'Timestamp'|
'Uncles'|
'BaseFeePerGas'|
'BlobGasUsed'|
'ExcessBlobGas'|
'ParentBeaconBlockRoot'|
'WithdrawalsRoot'|
'Withdrawals'|
'L1BlockNumber'|
'SendCount'|
'SendRoot'|
'MixHash';

/** Filter for selecting blocks based on hash and miner */
export interface BlockFilter {
  /**
   * Hash of a block, any blocks that have one of these hashes will be returned.
   * Empty means match all.
   */
  hash?: Array<string>
  /**
   * Miner address of a block, any blocks that have one of these miners will be returned.
   * Empty means match all.
   */
  miner?: Array<string>
}

/** Selection criteria for blocks with include and exclude filters */
export interface BlockSelection {
  /** Blocks that match this filter will be included */
  include: BlockFilter
  /** Blocks that match this filter will be excluded */
  exclude?: BlockFilter
}

/** Configuration for the hypersync client. */
export interface ClientConfig {
  /** HyperSync server URL. */
  url: string
  /** HyperSync server api token. */
  apiToken: string
  /** Milliseconds to wait for a response before timing out. Default: 30000. */
  httpReqTimeoutMillis?: number
  /** Number of retries to attempt before returning error. Default: 12. */
  maxNumRetries?: number
  /** Milliseconds that would be used for retry backoff increasing. Default: 500. */
  retryBackoffMs?: number
  /** Initial wait time for request backoff. Default: 200. */
  retryBaseMs?: number
  /** Ceiling time for request backoff. Default: 5000. */
  retryCeilingMs?: number
  /** Enable checksum addresses in responses. */
  enableChecksumAddresses?: boolean
  /** Query serialization format to use for HTTP requests. Default: Json. */
  serializationFormat?: SerializationFormat
  /** Whether to use query caching when using CapnProto serialization format. */
  enableQueryCaching?: boolean
}

/**
 * Column mapping for stream function output.
 * It lets you map columns you want into the DataTypes you want.
 */
export interface ColumnMapping {
  /** Mapping for block data. */
  block?: Record<string, DataType>
  /** Mapping for transaction data. */
  transaction?: Record<string, DataType>
  /** Mapping for log data. */
  log?: Record<string, DataType>
  /** Mapping for trace data. */
  trace?: Record<string, DataType>
  /** Mapping for decoded log data. */
  decodedLog?: Record<string, DataType>
}

/**
 * DataType is an enumeration representing the different data types that can be used in the column mapping.
 * Each variant corresponds to a specific data type.
 */
export type DataType =  'Float64'|
'Float32'|
'UInt64'|
'UInt32'|
'Int64'|
'Int32';

/** Decoded EVM log */
export interface DecodedEvent {
  indexed: Array<DecodedSolValue>
  body: Array<DecodedSolValue>
}

export interface DecodedSolValue {
  val: boolean | bigint | string | Array<DecodedSolValue>
}

/** Data relating to a single event (log) */
export interface Event {
  /** Transaction that triggered this event */
  transaction?: Transaction
  /** Block that this event happened in */
  block?: Block
  /** Evm log data */
  log: Log
}

/** Response from an event query */
export interface EventResponse {
  /** Current height of the source hypersync instance */
  archiveHeight?: number
  /**
   * Next block to query for, the responses are paginated so,
   *  the caller should continue the query from this block if they
   *  didn't get responses up to the to_block they specified in the Query.
   */
  nextBlock: number
  /** Total time it took the hypersync instance to execute the query. */
  totalExecutionTime: number
  /** Response data */
  data: Array<Event>
  /** Rollback guard, supposed to be used to detect rollbacks */
  rollbackGuard?: RollbackGuard
}

/** Collection of events from a blockchain query */
export interface Events {
  /** Current height of the source hypersync instance */
  archiveHeight?: number
  /**
   * Next block to query for, the responses are paginated so,
   *  the caller should continue the query from this block if they
   *  didn't get responses up to the to_block they specified in the Query.
   */
  nextBlock: number
  /** Total time it took the hypersync instance to execute the query. */
  totalExecutionTime: number
  /** Response data */
  events: Array<Event>
  /** Rollback guard, supposed to be used to detect rollbacks */
  rollbackGuard?: RollbackGuard
}

/** Selection of specific fields to return for each data type */
export interface FieldSelection {
  /** Block fields to include in the response */
  block?: Array<BlockField>
  /** Transaction fields to include in the response */
  transaction?: Array<TransactionField>
  /** Log fields to include in the response */
  log?: Array<LogField>
  /** Trace fields to include in the response */
  trace?: Array<TraceField>
}

/** Determines format of Binary column */
export type HexOutput = /** Binary column won't be formatted as hex */
'NoEncode'|
/** Binary column would be formatted as prefixed hex i.e. 0xdeadbeef */
'Prefixed'|
/** Binary column would be formatted as non prefixed hex i.e. deadbeef */
'NonPrefixed';

/** Mode for joining blockchain data */
export declare enum JoinMode {
  /** Default join mode */
  Default = 0,
  /** Join all available data */
  JoinAll = 1,
  /** Join no additional data */
  JoinNothing = 2
}

/**
 * Evm log object
 *
 * See ethereum rpc spec for the meaning of fields
 */
export interface Log {
  removed?: boolean
  logIndex?: number
  transactionIndex?: number
  transactionHash?: string
  blockHash?: string
  blockNumber?: number
  address?: string
  data?: string
  topics: Array<string | undefined | null>
}

/** Available fields for log data */
export type LogField =  'Removed'|
'LogIndex'|
'TransactionIndex'|
'TransactionHash'|
'BlockHash'|
'BlockNumber'|
'Address'|
'Data'|
'Topic0'|
'Topic1'|
'Topic2'|
'Topic3';

/** Filter for selecting logs based on address and topics */
export interface LogFilter {
  /**
   * Address of the contract, any logs that has any of these addresses will be returned.
   * Empty means match all.
   */
  address?: Array<string>
  /**
   * Topics to match, each member of the top level array is another array, if the nth topic matches any
   *  topic specified in topics[n] the log will be returned. Empty means match all.
   */
  topics?: Array<Array<string>>
}

/** Selection criteria for logs with include and exclude filters */
export interface LogSelection {
  /** Logs that match this filter will be included */
  include: LogFilter
  /** Logs that match this filter will be excluded */
  exclude?: LogFilter
}

/**
 * Returns a query object for all Blocks and hashes of the Transactions within the block range
 * (from_block, to_block].  Also returns the block_hash and block_number fields on each Transaction
 * so it can be mapped to a block.  If to_block is None then query runs to the head of the chain.
 */
export declare function presetQueryBlocksAndTransactionHashes(fromBlock: number, toBlock?: number | undefined | null): Query

/**
 * Returns a query for all Blocks and Transactions within the block range (from_block, to_block]
 * If to_block is None then query runs to the head of the chain.
 */
export declare function presetQueryBlocksAndTransactions(fromBlock: number, toBlock?: number | undefined | null): Query

/**
 * Returns a query object for all Logs within the block range from the given address.
 * If to_block is None then query runs to the head of the chain.
 */
export declare function presetQueryLogs(contractAddress: string, fromBlock: number, toBlock?: number | undefined | null): Query

/**
 * Returns a query for all Logs within the block range from the given address with a
 * matching topic0 event signature.  Topic0 is the keccak256 hash of the event signature.
 * If to_block is None then query runs to the head of the chain.
 */
export declare function presetQueryLogsOfEvent(contractAddress: string, topic0: string, fromBlock: number, toBlock?: number | undefined | null): Query

/** Query for retrieving blockchain data */
export interface Query {
  /** The block to start the query from */
  fromBlock: number
  /**
   * The block to end the query at. If not specified, the query will go until the
   *  end of data. Exclusive, the returned range will be [from_block..to_block).
   *
   * The query will return before it reaches this target block if it hits the time limit
   *  configured on the server. The user should continue their query by putting the
   *  next_block field in the response into from_block field of their next query. This implements
   *  pagination.
   */
  toBlock?: number
  /**
   * List of log selections, these have an or relationship between them, so the query will return logs
   * that match any of these selections.
   */
  logs?: Array<LogFilter | LogSelection>
  /**
   * List of transaction selections, the query will return transactions that match any of these selections and
   *  it will return transactions that are related to the returned logs.
   */
  transactions?: Array<TransactionFilter | TransactionSelection>
  /**
   * List of trace selections, the query will return traces that match any of these selections and
   *  it will re turn traces that are related to the returned logs.
   */
  traces?: Array<TraceFilter | TraceSelection>
  /** List of block selections, the query will return blocks that match any of these selections */
  blocks?: Array<BlockFilter | BlockSelection>
  /**
   * Weather to include all blocks regardless of if they are related to a returned transaction or log. Normally
   *  the server will return only the blocks that are related to the transaction or logs in the response. But if this
   *  is set to true, the server will return data for all blocks in the requested range [from_block, to_block).
   */
  includeAllBlocks?: boolean
  /**
   * Field selection. The user can select which fields they are interested in, requesting less fields will improve
   *  query execution time and reduce the payload size so the user should always use a minimal number of fields.
   */
  fieldSelection: FieldSelection
  /**
   * Maximum number of blocks that should be returned, the server might return more blocks than this number but
   *  it won't overshoot by too much.
   */
  maxNumBlocks?: number
  /**
   * Maximum number of transactions that should be returned, the server might return more transactions than this number but
   *  it won't overshoot by too much.
   */
  maxNumTransactions?: number
  /**
   * Maximum number of logs that should be returned, the server might return more logs than this number but
   *  it won't overshoot by too much.
   */
  maxNumLogs?: number
  /**
   * Maximum number of traces that should be returned, the server might return more traces than this number but
   *  it won't overshoot by too much.
   */
  maxNumTraces?: number
  /**
   * Selects join mode for the query,
   * Default: join in this order logs -> transactions -> traces -> blocks
   * JoinAll: join everything to everything. For example if logSelection matches log0, we get the
   * associated transaction of log0 and then we get associated logs of that transaction as well. Applites similarly
   * to blocks, traces.
   * JoinNothing: join nothing.
   */
  joinMode?: JoinMode
}

/** Response from a blockchain query */
export interface QueryResponse {
  /** Current height of the source hypersync instance */
  archiveHeight?: number
  /**
   * Next block to query for, the responses are paginated so,
   *  the caller should continue the query from this block if they
   *  didn't get responses up to the to_block they specified in the Query.
   */
  nextBlock: number
  /** Total time it took the hypersync instance to execute the query. */
  totalExecutionTime: number
  /** Response data */
  data: QueryResponseData
  /** Rollback guard, supposed to be used to detect rollbacks */
  rollbackGuard?: RollbackGuard
}

/** Data returned from a query response */
export interface QueryResponseData {
  /** Blocks returned by the query */
  blocks: Array<Block>
  /** Transactions returned by the query */
  transactions: Array<Transaction>
  /** Logs returned by the query */
  logs: Array<Log>
  /** Traces returned by the query */
  traces: Array<Trace>
}

export interface RollbackGuard {
  /** Block number of the last scanned block */
  blockNumber: number
  /** Block timestamp of the last scanned block */
  timestamp: number
  /** Block hash of the last scanned block */
  hash: string
  /**
   * Block number of the first scanned block in memory.
   *
   * This might not be the first scanned block. It only includes blocks that are in memory (possible to be rolled back).
   */
  firstBlockNumber: number
  /**
   * Parent hash of the first scanned block in memory.
   *
   * This might not be the first scanned block. It only includes blocks that are in memory (possible to be rolled back).
   */
  firstParentHash: string
}

/** Determines query serialization format for HTTP requests. */
export type SerializationFormat = /** Use JSON serialization (default) */
'Json'|
/** Use Cap'n Proto binary serialization */
'CapnProto';

/** Config for hypersync event streaming. */
export interface StreamConfig {
  /**
   * Column mapping for stream function output.
   * It lets you map columns you want into the DataTypes you want.
   */
  columnMapping?: ColumnMapping
  /** Event signature used to populate decode logs. Decode logs would be empty if set to None. */
  eventSignature?: string
  /** Determines formatting of binary columns numbers into utf8 hex. Default: NoEncode. */
  hexOutput?: HexOutput
  /** Initial batch size. Size would be adjusted based on response size during execution. Default: 1000. */
  batchSize?: number
  /** Maximum batch size that could be used during dynamic adjustment. Default: 200000. */
  maxBatchSize?: number
  /** Minimum batch size that could be used during dynamic adjustment. Default: 200. */
  minBatchSize?: number
  /** Number of async threads that would be spawned to execute different block ranges of queries. Default: 10. */
  concurrency?: number
  /** Max number of blocks to fetch in a single request. */
  maxNumBlocks?: number
  /** Max number of transactions to fetch in a single request. */
  maxNumTransactions?: number
  /** Max number of logs to fetch in a single request. */
  maxNumLogs?: number
  /** Max number of traces to fetch in a single request. */
  maxNumTraces?: number
  /** Size of a response in bytes from which step size will be lowered. Default: 500000. */
  responseBytesCeiling?: number
  /** Size of a response in bytes from which step size will be increased. Default: 250000. */
  responseBytesFloor?: number
  /** Stream data in reverse order. Default: false. */
  reverse?: boolean
}

/**
 * Evm trace object
 *
 * See ethereum rpc spec for the meaning of fields
 */
export interface Trace {
  from?: string
  to?: string
  callType?: string
  gas?: bigint
  input?: string
  init?: string
  value?: bigint
  author?: string
  rewardType?: string
  blockHash?: string
  blockNumber?: number
  address?: string
  code?: string
  gasUsed?: bigint
  output?: string
  subtraces?: number
  traceAddress?: Array<number>
  transactionHash?: string
  transactionPosition?: number
  type?: string
  error?: string
}

/** Available fields for trace data */
export type TraceField =  'ActionAddress'|
'Balance'|
'RefundAddress'|
'Sighash'|
'From'|
'To'|
'CallType'|
'Gas'|
'Input'|
'Init'|
'Value'|
'Author'|
'RewardType'|
'BlockHash'|
'BlockNumber'|
'Address'|
'Code'|
'GasUsed'|
'Output'|
'Subtraces'|
'TraceAddress'|
'TransactionHash'|
'TransactionPosition'|
'Type'|
'Error';

/** Filter for selecting traces based on various criteria */
export interface TraceFilter {
  from?: Array<string>
  to?: Array<string>
  address?: Array<string>
  callType?: Array<string>
  rewardType?: Array<string>
  type?: Array<string>
  sighash?: Array<string>
}

/** Selection criteria for traces with include and exclude filters */
export interface TraceSelection {
  /** Traces that match this filter will be included */
  include: TraceFilter
  /** Traces that match this filter will be excluded */
  exclude?: TraceFilter
}

/**
 * Evm transaction object
 *
 * See ethereum rpc spec for the meaning of fields
 */
export interface Transaction {
  blockHash?: string
  blockNumber?: number
  from?: string
  gas?: bigint
  gasPrice?: bigint
  hash?: string
  input?: string
  nonce?: bigint
  to?: string
  transactionIndex?: number
  value?: bigint
  v?: string
  r?: string
  s?: string
  yParity?: string
  maxPriorityFeePerGas?: bigint
  maxFeePerGas?: bigint
  chainId?: number
  accessList?: Array<AccessList>
  authorizationList?: Array<Authorization>
  maxFeePerBlobGas?: bigint
  blobVersionedHashes?: Array<string>
  cumulativeGasUsed?: bigint
  effectiveGasPrice?: bigint
  gasUsed?: bigint
  contractAddress?: string
  logsBloom?: string
  type?: number
  root?: string
  status?: number
  l1Fee?: bigint
  l1GasPrice?: bigint
  l1GasUsed?: bigint
  l1FeeScalar?: number
  gasUsedForL1?: bigint
}

/** Available fields for transaction data */
export type TransactionField =  'BlockHash'|
'BlockNumber'|
'From'|
'Gas'|
'GasPrice'|
'Hash'|
'Input'|
'Nonce'|
'To'|
'TransactionIndex'|
'Value'|
'V'|
'R'|
'S'|
'YParity'|
'MaxPriorityFeePerGas'|
'MaxFeePerGas'|
'ChainId'|
'AccessList'|
'AuthorizationList'|
'MaxFeePerBlobGas'|
'BlobVersionedHashes'|
'CumulativeGasUsed'|
'EffectiveGasPrice'|
'GasUsed'|
'ContractAddress'|
'LogsBloom'|
'Type'|
'Root'|
'Status'|
'L1Fee'|
'L1BlockNumber'|
'L1GasPrice'|
'L1GasUsed'|
'L1FeeScalar'|
'L1BaseFeeScalar'|
'L1BlobBaseFee'|
'L1BlobBaseFeeScalar'|
'GasUsedForL1'|
'Sighash'|
'BlobGasPrice'|
'BlobGasUsed'|
'DepositNonce'|
'DepositReceiptVersion'|
'Mint'|
'SourceHash';

/** Filter for selecting transactions based on various criteria */
export interface TransactionFilter {
  /**
   * Address the transaction should originate from. If transaction.from matches any of these, the transaction
   *  will be returned. Keep in mind that this has an and relationship with to filter, so each transaction should
   *  match both of them. Empty means match all.
   */
  from?: Array<string>
  /**
   * Address the transaction should go to. If transaction.to matches any of these, the transaction will
   *  be returned. Keep in mind that this has an and relationship with from filter, so each transaction should
   *  match both of them. Empty means match all.
   */
  to?: Array<string>
  /** If first 4 bytes of transaction input matches any of these, transaction will be returned. Empty means match all. */
  sighash?: Array<string>
  /** If tx.status matches this it will be returned. */
  status?: number
  /** If transaction.type matches any of these values, the transaction will be returned */
  type?: Array<number>
  contractAddress?: Array<string>
  /**
   * If transaction.hash matches any of these values, the transaction will be returned.
   * Empty means match all.
   */
  hash?: Array<string>
  /** If transaction.authorization_list matches any of these values, the transaction will be returned. */
  authorizationList?: Array<AuthorizationSelection>
}

/** Selection criteria for transactions with include and exclude filters */
export interface TransactionSelection {
  /** Transactions that match this filter will be included */
  include: TransactionFilter
  /** Transactions that match this filter will be excluded */
  exclude?: TransactionFilter
}

/**
 * Evm withdrawal object
 *
 * See ethereum rpc spec for the meaning of fields
 */
export interface Withdrawal {
  index?: string
  validatorIndex?: string
  address?: string
  amount?: string
}
